#N = 70823996418761472230940324261477630151174473746163139461088222318516515165841037819471846861414831170825396055487476964896444214632792400664929096088062779018852952932901929987831451521494420964909104386149225935474139319359517532831831998319673339794639329120114593876130992198276115032654748265211554901721052988523708492481264679395531694495682637963219956757118102799555831232911184999173025432856769997366825844622108171134084928567106141167421858192354750603836611325301855027334392111115877799667139900364160532123427152736697265613093603896313713040335776125786791751240995104833009057988800680852162110409527

#e = 70468792245264589410221617888922699822924006960689667986164210399294653838262795832620497823351192253548160555217526498755329740907274429007123844219685008572171118206320710693445291121165714729372421318919389563928025750816691476864295711674425720421727253073036623935446741469839175118243321229798808928971367651270161674622302828627703920422141329135883072167926428100244105384829529946482281943183872654196986756688781491652635465390978872323833880594185787885013987279637781805977532383272267841663943423005353137009490274459145678763261350932468542050531077024364907423505481047183685080600118282108359486101079 


#prime1 = random_prime(2^1025-1, None, 2^1024)
#prime2 = random_prime(2^1025-1, None,2^1024)
#print "prime1- " + str(prime1)
#print "prime2- " + str(prime2)
#N = prime1*prime2
#print (1.0/3.0)*(N^(0.25))
#
#e = 25411171
def wieners_attack(input):
	N = input['N']
	e = input['e']

	#cont_fraction = input["continued_fraction"]
	cont_fraction =  continued_fraction(ZZ(e)/ZZ(N))
	print("The continued fraction e/N - " + str(cont_fraction))
	convergents = []
	for i in range(0,len(cont_fraction)):
	    convergents.append([cont_fraction.numerator(i), cont_fraction.denominator(i)])
	print("Convergents of the continued fraction(in the form k/d)- "+ str(convergents))

	D=0 #value of d to be returned by default
	for (k,d) in convergents:
		if(k != 0):
			check = (e*d-1)%ZZ(k)
			if((d%2 !=  0) and (check == ZZ(0))):
				phi = (e*d-1)/k
				print "phi- "+ str(phi)
				a, b, c = ZZ(1), ZZ(phi-N-1), ZZ(N)
				qe = (a*x^2 + b*x + c == 0)
				solution = solve(qe, x)
				print "Possible Solution1(p)- " + str(solution[0].operands()[1])
				print "Possible Solution2(q)- " + str(solution[1].operands()[1])
				try:
					p = ZZ(solution[0].operands()[1])
					q = ZZ(solution[1].operands()[1])
					D=d
				except:
					print "Roots p and q are not integers."
	result = {}
	result["results"] = D
	result["errors"]  = "No error"
	#print result
	if(D == 0):
		result["errors"] = "No possible solutions found."
	return result
#wieners_attack({"N":N, "e":e})


